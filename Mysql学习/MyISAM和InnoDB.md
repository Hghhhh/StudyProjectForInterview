Mysql的锁有如下几种：

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大；发生锁冲突的概率最高，并发度最低。MyISAM使用这种类型。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发送锁冲突的概论最低，并发度也最高。InnoDB属于这种类型。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。NDB属于这种类型。

表锁：

MyISAM只支持表锁，所以对MyISAM表进行操作，会存在下面情况：

- 对MyISAM表的读操作（加读锁），不会阻塞其他教程对同一张表读请求，但会阻塞对同一张表的写请求。
- 对MyISAM表的写操作（加写锁），会阻塞其他进程对同一张表的读和写操作。

eg：

```Asql
A:lock table tb_user read;(lock table tb_users write)
B:update tb_user set userName = '123' where userId=1;
//等待
A:unlock tables;
B:Query OK;
```

行锁：

**InnoDB存储引擎是通过给索引上的索引项加锁来实现的，这意味着：如果不使用索引，InnoDB将使用表锁。**

InnoDB和MyISAM性能比较：

- MyISAM支持全文索引，但不是事务安全的，不支持外键。每张MyISAM表存放在三个文件中：.frm文件存放表格定义；数据文件是MYD；索引文件是MYI。
- MyISAM可以手工或自动执行检查或修复操作，这一点要注意跟InnoDB的事务恢复区分开来。
- InnoDB是事务型引擎，具有崩溃回复能力，多版本并发控制（MVCC），支持ACID事务，支持行级锁定，锁管理开销大。
- MyISAM表相对简单，管理方便，因此在效率上优于InnoDB，小型应用可以考虑使用MyISAM。
- InnoDB比MyISAM更加安全，可以保证数据不会丢失的情况下，切换非事务表到事务表。



附录：什么是多版本并发控制（MVCC）？
MVCC是让每个事务在运行时看到的是数据库的一个快照。

InnoDB为每行数据增加两个隐含值，这两个值分别记录了行的创建时间以及它的过期时间（或叫删除时间）。每一行都存储了事件发生时的系统版本号，用来代替时间发生时的实际时间。每一次，开始一个新的事务时，版本号会自动递增。每个事务都会保存它在开始时的“当前系统版本”的记录，而每次查询都会根据事务的版本号，检查每行数据的版本号。MVCC在实际中的应用方式：

- SELECT：InnoDB检查每行数据，确保它符号下面两个标准：

  （1）InnoDB只查找创建版本早于当前事务版本的数据行，这确保了当前事务读取的行都是在事务开始前已经存在的，或者是由当前事务创建或修改的行。

  （2）数据行的删除版本必须是未定义或大于事务版本的，这保证了事务读取的行是在事务开始前删除的。

- DELETE: InnoDB为删除行记录当前系统版本号，作为行删除标识。

- INSERT：InnoDB为每个新增行记录当前系统版本号。

- UPDATE：InnoDB会为每个需要更新的行，建立一个新的行拷贝，并为新拷贝记录当前的版本号。同时，为更新前的旧行，添加当前系统版本号作为删除标识。

保存这些额外记录的好处是使大多数读操作都不必申请加锁，这使得读操作变得尽可能的快。缺点是存储引擎必须为每行数据存储额外数据，做更多的检查工作和额外操作。

MVCC只工作在REPEATABLE READ 和READ COMMITTED两个隔离级。READ UNCOMMITTED隔离级不兼容MVCC，这是因为在任何情况下，该隔离级下的查询不读取符合当前事务版本的数据行，而读取最新版本的数据行。SERIALIZABLE隔离级也不兼容MVCC，这是因为每次读操作都会加锁，没必要用MVCC。



补充下我对MVCC工作在REPEATABLE READ隔离级别下的理解：
MVCC读的时候没有加读锁，写的时候还是需要加写锁的，两个事务要写操作同一行数据，还是要按加锁顺序来访问的。