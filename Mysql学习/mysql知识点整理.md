---
title: MySQL知识点整理
date: 2019-02-25 11:51:56
tags:  MySQL
---



# 一、MySQL的逻辑架构

![mysql的逻辑结构](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/mysql/mysql%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png)

简单来说mysql分为Server层和存储引擎层

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖mysql的大部分服务功能，以及所有的内置函数，所有的跨存储引擎的功能都在这一层，比如存储过程、视图等。

存储引擎层提供读写数据的接口，常用存储引擎包括InnoDB、MyISAM、Memory等，5.5之后默认的是InnoDB。

下面解释下每个组件的作用：

##连接器

当你使用类似这样的命令`mysql -h127.0.0.1 - P3306 -uroot -p123456`去连接数据库的时候，接待你的就是连接器。连接器负责创建连接、获取权限、维持和管理连接。

（1）流程如下：

```用户发起连接请求-&gt;TCP握手-&gt;输入密码（如果还没输入的话）-&gt;连接器去权限表获取权限-&gt;依赖于得到的进行查询
用户发起连接请求->TCP握手->输入密码（如果还没输入的话）->连接器去权限表获取权限->依赖于得到的权限进行查询
```

这就意味着，一个用户成功建立连接后，即使你用管理员账号修改这个用户的权限，在这个连接中用户还是原来的权限。

（2）常用查看命令：

- show processlist：可以查看已经创建的连接

（3）有关参数：

- wati_timeout ：空闲连接的连接时间最久可以是多少

（4）什么是长连接、短连接：
长连接：是指用户创建一个连接后，如果持续有请求，则一直使用同一个连接

短连接：每次只执行很少的操作就断开连接，下次再重新创建连接。

（5）长连接有什么好处？缺点呢？
好处：创建连接的代价通常是高的，使用长连接减少连接开销代价。

缺点：使用长连接，连接对象中占用的内存会一直积压，直到释放连接才释放，如果内存占用太多，会被系统强制杀掉，导致mysql异常重启。

（6）怎么解决长连接的内存问题？

- 定期断开长连接。

- 如果使用的是mysql5.7以上的版本，可以在一次比较大的操作后，使用`mysql_reset_connection`,这个操作不会断开连接，而是将连接恢复到刚创建时的状态。

## 查询缓存

因为mysql的会把sql语句和返回值缓存成key-value的形式。创建连接之后，执行select语句，会先查询mysql的缓存中有没有这条语句，有就返回value，没有就执行后面步骤。

（1）要不要开启mysql的缓存功能？
对于那些不经常变动的表，可以开启缓存，对于频繁变动的表，关闭缓存。因为每次表的数据发生了变化，这个表的所有缓存就会失效，这样的话缓存起不来什么作用还会增加了开销。

（2）怎么开启缓存、关闭缓存？

通过`query_cache_type`开启和关闭缓存；

还可以在每条select语句中的select后面加上`SQL_CACHE`、`SQL_NO_CACHE`来指定这条sql语句开启和不开启缓存。

需要注意的是MySQL8.0已经彻底去掉了缓存这个功能了。

## 分析器

进行词法分析和语法分析

词法分析主要分析分析出sql语句中的字符串分别是什么，代表什么，比如selete后面的代表字段，from后面的代表表。另外检查要操作的表存不存在或者这个列存不存在也是在这里。

语法分析主要分析执行的sql语句是否符合sql的语法规定。

##优化器

优化器是在有多个索引的时候决定使用那个索引，连表查询的时候决定各表的连接顺序。

同样的执行结果，根据sql语句内查询顺序不一样执行效率会不同，由优化器来决定使用哪种方案。

## 执行器

执行步骤：
判断权限->去存储引擎获取数据返回->如果满足条件，继续去存储引擎的下一行->将满足的行的结果集返回

（1）我们怎么知道执行器扫描了多少行？

慢查询日志的`rows_examined`字段就是表示这个语句在执行的时候扫描了多少行的。

还可以通过`explain`的`row`字段查看。

## 存储引擎

（1）MyISAM和InnoDB的区别是什么？

- MyISAM不是事务安全的，不支持外键。
- MyISAM只支持表锁，不支持行锁
- InnoDB是事务型引擎，具有崩溃回复能力，多版本并发控制（MVCC），支持ACID事务，支持行级锁定，锁管理开销大。
- MyISAM表相对简单，管理方便，因此在效率上优于InnoDB，小型应用可以考虑使用MyISAM。
- InnoDB比MyISAM更加安全，可以保证数据不会丢失的情况下，切换非事务表到事务表。



#二、日志系统：一条sql更新操作是怎么执行的

mysql有两种日志redo-log和bin-log

**（1）redo-log是怎么工作的？**

执行更新操作的时候，InnoDB引擎先将记录写到redo-log里，然后更新内存，这时候更新操作就算完成了。然后在适当的时候再将redo-log中的内容写到磁盘的数据文件中，这个时机往往是系统比较空闲的时候或者redo-log已经写满了得时候。

有了redo-log，InnoDB就可以保证即时数据库发送异常重启，也能从redo-log中恢复数据，这个能力叫做crash-safe。

![](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/mysql/redo-log.jpg)

**（2）为什么要有两种日志？**
①因为redo-log是InnoDB特有的，所以要有bin-log给其他引擎使用；

②redo-log是循环写的，不能持久化，bin-log是可以追加写的，一个文件写满了后可以写到下一个，提供了redo-log没有的“归档”的功能。

**（3）redo-log和bin-log的区别**

- redo-log是InnoDB特有的，bin-log在Server层可以给其他引擎使用
- redo-log是物理日志，记录的是在”某个数据页做了什么修改“；bin-log是逻辑日志，记录的是原始语句的逻辑，例如“给id=2这一行的c加1”这样的
- redo log 是循环写的,空间固定会用完;binlog 是可以追加写入的。“追加写”是指 bin-log文件写到一定大小会写到写一个文件，不会覆盖写的。



**（4）redo-log和bin-log怎么保持一致？**

使用两阶段提交的方式。

![](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/mysql/redo-log%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png)

上面的流程，写入redolog的时候先是prepare阶段，写完binlog后，再将redolog写入的变成commit状态，这样即使写入的途中redolog或binlog有一个突然崩溃了没写入，类似事务，可以通过让redolog回滚的方法来保证一致性。

**（5）bin-log有哪两种存储形式？**
row：存储的是更新前和更新后的两行数据
statement：存储的是执行的语句

**（6）怎么开启bin-log？**
使用参数`sql_log_bin`开启和关闭bin-log



# 三、事务

**（1）事务的四个特性是什么？**

- 原子性（Atomicity）:同一个事物中的操作要么全部成功，要么全部失败
- 一致性（Consistency）：事务必须保持系统属于一致的状态，就像能量守恒一样，自然界中获得的能量和失去能量总是一样的。
- 隔离性（Isolation）：各个事务执行的时候不会相互影响的性质
- 持久性（Durability）：在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

**（2）mysql的有哪些事务隔离级别？**

- 读未提交（read uncommited）：一个事务可以读到另一个事务未提交的数据
- 读提交（read commited）：一个事务只能读到另一个事务提交的数据
- 【MySQL默认】可重复读（repeatable read）：一个事务读到的数据和事务刚开始的时候是一样的
- 序列化（serializable）：对同一行数据，读的时候加读锁，写的时候加写锁，如果发生了读写锁冲突，则让前面的事务先执行完后面的才能执行

**（3）使用各个事务隔离级别各有什么缺点？**

- 使用读未提交会读取到脏数据，如果下一秒有事务发送了回滚，那么先前读到的数据就是脏的。
- 使用读提交可能会出现不可重复读的情况，当前读到的数据，下一秒可能会发生变化。
- 可重复读可能出现幻读，就是之前没有读到的数据，在有事务插入数据后，再读一次会有多出来的数据，但是使用了MVCC之后，这个问题已经解决了
- 序列化很明显性能不高

**（4）怎么设置事务隔离级别？**

通过参数`tx_isolation`来设置（5.7之后是`transaction_isolation`）

**（5）什么是MVCC？（多版本并发控制）**

MVCC是通过及时保存每个事务的快照来实现的。这意味着同一个事务在运行时看到的数据视图是一致的，而同一个时间，同一张表，不同事务之间看到的数据是不同的。

具体是这样实现的：

InnoDB会给每个事务一个版本号，给每行数据维护两个数值：当前版本号和过期版本号，当前版本号每次有新事务就递增。每个事务只能读到比自己版本旧的数据或者或者在自己版本之前被删除的数据，删除数据的时候把自己的版本号赋值给这一行的过期版本号，读到的数据作为这个事务的快照；更新数据的时候先复制一行旧数据，再用自己的版本号给旧数据加上删除的版本号，给新数据加上当前版本号

**（6）为什么不要使用长事务？**

在事务中每个操作都要记录前一个状态以进行回滚，如果事务过长，回滚段就会一直增加，导致占用大量的存储空间。同时长事务会长时间占用锁资源，拖垮数据库。





# 四、索引

1.索引的作用：提高数据查询效率。
2.常见索引模型：哈希表、有序数组、搜索树。
3.哈希表：键 - 值(key - value)。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。
5.哈希冲突的处理办法：链表。
6.哈希表适用场景：只有等值查询的场景，**如果要进行范围查询，需要进行全表扫描**。
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))
8.有序数组查询效率高，更新效率低，更新的时候需要移动后面的元素。
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子。
11.二叉搜索树：查询时间复杂度O(log(N))，更新时间复杂度O(log(N))。
12.数据库存储大多不适用二叉树，**因为树高过高**，每次拿节点都需要去硬盘中拿，这样的话操作硬盘的次数就会比较多，会适用N叉树。
13.InnoDB中的索引模型：**B+Tree**。
14.索引类型：主键索引、非主键索引，**主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)。**
15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(**回表**)
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做**页分裂**，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据**页合并**，合并的过程是分裂过程的逆过程。

17.从性能和存储空间方面考量，**自增主键**往往是更合理的选择，因为自增主键小，那个普通索引的叶子节点是自主主键，普通索引的B+树占用的空间就小。

18.覆盖索引：建立联合索引，让联合索引覆盖要查询的字段

19.最左前缀：联合索引中只有前面的字段满足使用索引的条件，才使用后面的字段索引



# 五、一些mysql性能调优的建议

（1）最主要的部分应该是sql语句调优：

合理使用索引：

0. 如果可以的话给频繁用来查询的字段加上索引，加快查询速度。
1. 必要时可以添加联合索引，来覆盖返回结果。
2. 注意最左前缀匹配，保证查询的sql语句按照创建的索引顺序来查找，避免创建冗余索引
3. 用like进行模糊查询的时候不要使用‘%like%’，而尽量使用‘like%’的形式。另外使用regexp也是不会使用索引的。
4. 如果字段使用了函数或者运算操作是不会使用索引的
5. 多使用explain去分析sql语句
6. 使用union代替or，因为or很多时候是不会使用索引的
7. 使用jion代替in、exist等子查询

（2）配置调优

0. 选择合适的存储引擎，如果是一个不经常修改的表，而且不需要事务的支持，而且这个表经常要count（*），可以使用MyISAM，因为MyISAM没有行锁、事务这些东西，相对简单，性能更优。
1. 对于修改频繁的表关闭mysql的缓存功能，因为如果这个表有修改的话，所有缓存都会失效，缓存没起到什么作用，反而加大了维护缓存的开销（配置query_cache_type）
2. 开启slow_query_log慢查询日志，long_query_time可以根据业务设置，分析执行缓慢的sql语句
3. 对于频繁操作数据库的业务，连接的时候wati_timeout 可以设置大一些，避免频繁创建连接
4. 使用连接池

