数据库操作过程中可能出现下面几种不确定情况：

- 更新丢失（Lost update）：两个事务同时更新一行数据，但是第二个事务却中途失败退出，导致两个修改都丢失了。这是因为系统没有进行任何的锁操作，因此并发事务并没有被隔开来。
- 脏读（Dirty Reads）：一个事务读取了某行另外一个事务已经更新但没有及时提交的数据，但这个事务回滚了，读数据的事务读到的就是脏数据。
- 不可重复读（Non-repeatable Reads）：一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如在两次读取途中，另外一个事务对数据进行了修改。
- 两次更新问题（Second lost updates problem）：无法重复读取的特例。有两个并发事务同时读取了同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失败。
- 幻读（Phantom Reads）：事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现过的数据。这是因为在两次查询的过程中有另外一个事务插入了数据。

事务隔离级别：

- Read Uncommitted（未授权读取、读未提交）：如果一个事务已经开始写数据，就不允许其他事务同时进行写操作，但允许其他事务读此行数据。允许脏读取，但不允许更新丢失。
- Read Committed（授权读取，读提交）：读取数据的事务允许其他事务继续访问该行，但未提交的写事务将会禁止其他数据访问该行。允许不可重复读取，但不允许脏读取。
- （Mysql默认）Repeatable  Read（可重复读）：读取的数据的事务禁止其他事务对该行的写操作，写操作的事务还是禁止其他事务对该行的所有操作。禁止不可重复读取和脏读取，但允许幻影读取。通过共享读锁和排他写锁来实现。
- Serializable（序列化）：要求事务序列化执行，提供严格的事务隔离。

间隙锁：防止幻读，用在REPEATABLE-READ隔离级别下，指的是当对数据进行条件、范围检索时，对其范围内也许并不存在的值进行加锁。

eg:

```sql
select * from tb_user where id<8 lock in share mode;
```

上面的语句锁定了一个范围（id<8），那么其他事务再向其插入小于8的值时，就会被锁住，但大于8是可以插入的。