#HashSet和TreeSet的区别？

- hashSet是无序的，TreeSet是有序的，通过元素实现Comparable，或指定Comparator来排序
- hashSet是使用了HashMap来实现排重，TreeSet是基于TreeMap来实现的，它的底层是红黑树
- hashset是hash函数来定位的，一般来说效率会比treeSet高一些，如果仅仅是用来存储不重复的元素，使用hashset，如果需要得到一个排序的结果，才去使用TreeSet

#HashMap和TreeMap的区别？
hashMap不保证元素的顺序，它就是一个散列桶，根据key的hashcode放在桶中的某个位置。允许key为null

treeMap是基于红黑树实现的，它会按照Comparable接口的compareto方法或Comparator来排列元素，不允许key为null。

如果我们只是想要一个key-value的存储，我们使用hashMap就够了，因为hash的查找效率比红黑树高，当需要让元素排序是时候再使用treeMap



#LinkedHashMap的使用场景？
linkedHashMap实现了hashMap，在这个基础上加入链表，数据存入集合的时候，先根据hashmap的流程存放入数组中。然后再根据链表的原则，进行链接。这样我们既可以快速定位，又可以按照插入顺序访问。

LinkedHashMap适合有加入顺序和快速定位的场景。我自己开发中遇到过一个场景，就是把配置顺序读取，需要按照读取的顺序访问，而且还需要根据值key直接获取值。

还有一种情况是用来做缓存，它有两种缓存方法：FIFO，LRU。默认是FIFO，我们使用构造方法设置accessOrder为true，可以指定使用LRU。LRU开启的时候每次访问一个元素会把这个元素放到链表尾。



#代理模式是什么？
给一个对象提供一个代理，通过代理对象来控制对原对象的访问

代理模式的核心模块

- 抽象主题角色：声明了要实现的接口
- 真实主题角色：实现抽象主题角色的接口，是一些具体业务的实现
- 代理主题角色：包含了对真实主题的引用，通过它来控制对真实主题角色的访问。

UML图：
![](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(4).png)

典型应用是AOP，无需修改真实主题角色的代码，通过代理类来加一些与业务无关的代码，符号开闭原则。

能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。

代理又包括静态和动态两种，静态的缺点是，代理类要有和主题角色一样的接口，主题角色的接口增加或删除了，代理类也得改。

而动态代理可以通过invoke方法动态调用主题角色的方法。



# 简单工厂模式、工厂模式、抽象工厂模式的区别

简单工厂：一个工厂包含所有实例的创建逻辑不符合责任分配逻辑

工厂：不再有一个核心工厂去创建所有对象，而是指定一个工厂接口，由其他子类工厂来实现对象的创建。优点是满足依赖倒置原则，里氏替换原则等

抽象工厂：当需要创建多个相互关联的对象的时候，使用抽象工厂模式创建。优点和工厂差不多

工厂模式和构造者模式的区别？
工厂模式一般是创建一个产品，注重的是把这个产品创建出来，不关心这个产品的组成部分。

构造者模式也是创建产品，它还要关心这个产品的组成细节，组成过程。



# 带宽

[计算机网络](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)的带宽是指网络可通过的最高数据率，即每秒多少[比特](https://baike.baidu.com/item/%E6%AF%94%E7%89%B9)。

带宽越高传输速度越快

局域网的带宽一般是10M-100Mbps

硬盘和内存的读取速度：
一般硬盘的读取速度为60-100MB/s

一般内存的读取速度是硬盘的几十倍



# T、E、?、Null区别

ava泛型中的标记符含义： 

 E - Element (在集合中使用，因为集合中存放的是元素)

 T - Type（Java 类）

 K - Key（键）

 V - Value（值）

 N - Number（数值类型）

？ -  表示不确定的java类型

 S、U、V  - 2nd、3rd、4th types



Object跟这些标记符代表的java类型有啥区别呢？  

Object是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。

#SpringAOP的原理

springAop使用了动态代理，如果要代理的类实现了接口，就是使用JDK动态代理，否则使用cglib

为什么会这样?
因为jdk动态代理类继承了一个Proxy类，在Java中它没有办法再继承代理类来实现和代理类的关联，所以只能要求代理类有实现了接口，通过接口来关联代理类。而cglib就没有这种情况。



一些概念：
切点：就是我们要代理的方法

通知：在切点前后执行的代码

切面：就是切点和通知组成的，定义通知再哪个切点上。

织入：把切面的代码应用到目标方法上的过程。



通知的类型：

before

after

after throwing

after returing

aroud





一年问的比较泛，
1. java有哪些关键字，说一下访问修饰符

int、byte、char、String、float、double、long、boolean

public、private、protected，如果不加的话是default

static  void  synchronized，volatile，import、package

1. 线程池有哪些常用参数

```
corePoolSize：核心线程数
maximumPoolSize：最大线程数
keepAliveTime：超过核心数量的空闲线程的存活时间
unit:存活时间的单位
workQueue：存放任务的队列
```

1. TCP三次握手

```
1.服务端处于被动打开的状态等待连接
2.客户端主动打开连接，向服务端发送一个SYN请求同步报文，然后客户端进入SYN-SEND状态
3.服务端接收到SYN报文后，访问一个SYN+ACK报文，然后进入SYN-RECV状态
4.客户端接收到报文后，返回一个ACK报文然后进入ESTABLISH状态
5.服务端接收到最后一个ACK报文，也进入ESTABLISH状态
6.开始传输数据
7.前面两次握手不会包含实际的数据都是一些SYN、ACK这些控制信息，但也要占用一个序号；
最后一次握手的报文是可以存放数据的，HTTP协议就是在第三次握手的时候将请求报文发送了过去
```



1. 说一下final关键字

```java
final的意思是不可以变
1）修饰变量，被final修饰的变量必须要初始化，赋初值后不能再重新赋值。
如果修饰的是基本数据类型，值不能修改
如果修饰的是对象，对象的属性可以修改
　注意：局部变量不在我们讨论的范畴，因为局部变量本身就有作用范围，不使用private、public等词修饰。
2）修饰方法，被final修饰的方法代表不能重写。
3）修饰类，被final修饰的类，不能够被继承。
注意：final修饰的类，类中的所有成员方法都被隐式地指定为final方法。

```

1. java常用集合框

   ```java
   ArrayList，LinkedList，Vector，PriorityQueue
   HashSet，TreeSet，LinkedHashSet
   HashMap，HashTable，LinkedHashMap，ConcurrerntHashMap，TreeMap
   ```

2. 手写反转链表

```java
Node pre = null;
Node next=null;
Node cur = head;
while(cur!=null){
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
}
```



1. 聊聊人生



二面，按着简历问
1. 类加载机制

```java
类加载时机：
new一个对象的时候，或者访问类的静态字段、静态方法的时候
对类进行反射调用的时候，Class.forName(xxx)；
初始化一个类的时候，发现其父类没有初始化
jvm启动的时候，main方法那个类会被初始化

类加载过程
加载（将二进制文件加载到方法区，变成动态存储结构，同时方法区中创建一个class对象代表该类），验证（确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全，包括了文件格式验证、元数据验证、字节码验证、符号引用验证），准备（给类变量赋0值，除非是final类变量才赋规定的值），解析（虚拟机将常量池内的符号引用替换为直接引用的过程，包括类或接口解析，字段解析，类方法、接口方法解析），初始化（而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，即执行<clinit>方法）

类加载器
完成通过类的全限定名获得该类的二进制字节流的过程的工具叫类加载器
判断两个类是否相同，前提就是它们是由同一个类加载器加载的

```



1. 垃圾回收机制和内存分配

```java
引用计数法
GCRoot可达性分析法，gcroot可以是方法区中静态属性、常量所引用的对象，虚拟机栈中引用的对象，本地方法栈中引用的对象

回收算法：标记清除，标记整理，复制算法，分代回收算法


内存分为方法区，堆，虚拟机栈，程序计数器，本地方法栈
方法区中存放类的信息、静态变量、常量
堆中存放对象实例
虚拟机栈是方法执行的内存模型
程序计数器是当前线程的执行到的字节码的行号指示器
本地方法栈是本地方法的内存模型
```



1. 乐观锁和悲观锁的区别

```java
乐观锁总是假设每次去拿数据的时候，数据不会被修改，所以不会加锁，但是在更新的时候，会判断一下数据是否被修改过，一般使用CAS实现，如果更新的时候数据被修改了，一般使用自旋的方式重试一次操作。适用于读多写少的情况。

悲观锁总是假设拿到的数据会被其他线程修改，所以每次都给数据加锁，向synchronized、ReentrantLock还有mysql中的行锁都是悲观锁，适合读多写少的场景

乐观锁的缺点
ABA 问题是乐观锁一个常见的问题

1 ABA 问题
如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。
JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

2 循环时间长开销大
自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

3 只能保证一个共享变量的原子操作
CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。
```



1. java中有那些锁

```java
重量级锁，synchronized、ReentrantLock
轻量级锁，锁的时候会复制一份MarkWord到虚拟机栈中，然后把对象的MarkWord设置为轻量级锁的状态，释放的时候使用CAS操作将MarkWord恢复，如果发生了线程竞争锁，轻量级锁就会膨胀为重量级锁
偏向锁，适用于锁只被一个线程占用的情况，markword中指向偏向的线程，每次该线程都不用加锁，如果发送了锁竞争，那么就膨胀为轻量级锁或重量级锁
公平锁：等待锁时间久的先获取锁，性能比非公平锁差，因为线程切换次数多了，但避免了饥饿现象
自旋锁：一般和CAS一起使用，发现CAS失败的时候，不会进入阻塞状态，而是让CPU进行自旋，会消耗大量CPU，适用于条件一般很快就会满足的情况
```



1. 什么是双亲委派模型，为什么使用双亲委派模型

```java
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
好处是：Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。 
```

2.破坏双亲委派模型

```java
通过线程上下文类加载器来完成Thread.setContextClassLoader()
```

