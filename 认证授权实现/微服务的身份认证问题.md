## 四种解决方案

David Borsos 在伦敦的微服务大会上提出了四种方案：

**1. 单点登录（SSO）**

这种方案意味着每个面向用户的服务都必须与认证服务交互，这会产生大量非常琐碎的网络流量和重复的工作，当动辄数十个微应用时，这种方案的弊端会更加明显。

**2. 分布式 Session 方案**

分布式会话方案原理主要是将关于用户认证的信息存储在共享存储中，且通常由用户会话作为 key 来实现的简单分布式哈希映射。当用户访问微服务时，用户数据可以从共享存储中获取。在某些场景下，这种方案很不错，用户登录状态是不透明的。同时也是一个高可用且可扩展的解决方案。这种方案的缺点在于共享存储需要一定保护机制，因此需要通过安全链接来访问，这时解决方案的实现就通常具有相当高的复杂性了。

**3. 客户端 Token 方案**

令牌在客户端生成，由身份验证服务进行签名，并且必须包含足够的信息，以便可以在所有微服务中建立用户身份。令牌会附加到每个请求上，为微服务提供用户身份验证，这种解决方案的安全性相对较好，但身份验证注销是一个大问题，缓解这种情况的方法可以使用短期令牌和频繁检查认证服务等。对于客户端令牌的编码方案，Borsos 更喜欢使用 JSON Web Tokens（JWT），它足够简单且库支持程度也比较好。

**4. 客户端 Token 与 API 网关结合**

这个方案意味着所有请求都通过网关，从而有效地隐藏了微服务。 在请求时，网关将原始用户令牌转换为内部会话 ID 令牌。在这种情况下，注销就不是问题，因为网关可以在注销时撤销用户的令牌。

## 微服务常见安全认证方案

### HTTP 基本认证

HTTP Basic Authentication（HTTP 基本认证）是 HTTP 1.0 提出的一种认证机制，这个想必大家都很熟悉了，我不再赘述。HTTP 基本认证的过程如下：

1. 客户端发送 HTTP Request 给服务器。
2. 因为 Request 中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 Header "WWW-Authenticate" 中添加信息。
3. 客户端把用户名和密码用 BASE64 加密后，放在 Authorization Header 中发送给服务器， 认证成功。
4. 服务器将 Authorization Header 中的用户名密码取出，进行验证， 如果验证通过，将根据请求，发送资源给客户端。



### 基于 Session 的认证

基于 Session 的认证应该是最常用的一种认证机制了。用户登录认证成功后，将用户相关数据存储到 Session 中，单体应用架构中，默认 Session 会存储在应用服务器中，并且将 Session ID 返回到客户端，存储在浏览器的 Cookie 中。

但是在分布式架构下，Session 存放于某个具体的应用服务器中自然就无法满足使用了，简单的可以通过 Session 复制或者 Session 粘制的方案来解决。

Session 复制依赖于应用服务器，需要应用服务器有 Session 复制能力，不过现在大部分应用服务器如 Tomcat、JBoss、WebSphere 等都已经提供了这个能力。

除此之外，Session 复制的一大缺陷在于当节点数比较多时，大量的 Session 数据复制会占用较多网络资源。Session 粘滞是通过负载均衡器，将统一用户的请求都分发到固定的服务器节点上，这样就保证了对某一用户而言，Session 数据始终是正确的。不过这种方案依赖于负载均衡器，并且只能满足水平扩展的集群场景，无法满足应用分割后的分布式场景。

在微服务架构下，每个微服务拆分的粒度会很细，并且不只有用户和微服务打交道，更多还有微服务间的调用。这个时候上述两个方案都无法满足，就要求必须要将 Session 从应用服务器中剥离出来，存放在外部进行集中管理。可以是数据库，也可以是分布式缓存，如 Memchached、Redis 等。这正是 David Borsos 建议的第二种方案，分布式 Session 方案。



### 基于 Token 的认证

随着 Restful API、微服务的兴起，基于 Token 的认证现在已经越来越普遍。Token 和 Session ID 不同，并非只是一个 key。Token 一般会包含用户的相关信息，通过验证 Token 就可以完成身份校验。像 Twitter、微信、QQ、GitHub 等公有服务的 API 都是基于这种方式进行认证的，一些开发框架如 OpenStack、Kubernetes 内部 API 调用也是基于 Token 的认证。基于 Token 认证的一个典型流程如下：

1. 用户输入登录信息（或者调用 Token 接口，传入用户信息），发送到身份认证服务进行认证（身份认证服务可以和服务端在一起，也可以分离，看微服务拆分情况了）。
2. 身份验证服务验证登录信息是否正确，返回接口（一般接口中会包含用户基础信息、权限范围、有效时间等信息），客户端存储接口，可以存储在 Session 或者数据库中。
3. 用户将 Token 放在 HTTP 请求头中，发起相关 API 调用。
4. 被调用的微服务，验证 Token 权限。
5. 服务端返回相关资源和数据。

基于 Token 认证的好处如下：

1. 服务端无状态：Token 机制在服务端不需要存储 session 信息，因为 Token 自身包含了所有用户的相关信息。
2. 性能较好，因为在验证 Token 时不用再去访问数据库或者远程服务进行权限校验，自然可以提升不少性能。
3. 支持移动设备。
4. 支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。



转自：

[深入聊聊微服务架构的身份认证问题](https://www.infoq.cn/article/identity-authentication-of-architecture-in-micro-service)



## 用户身份认证和Oauth2授权的区别

（1）Oauth2授权

Oauth2授权授予权限的客户端一般是第三方应用，比如某个网站要获取微信用户的信息，需要到微信服务器获取access_token，第三方网站再通过acces_token再到微信的资源服务器获取用户信息

（2）用户身份认证

用户身份认证是后台服务对用户信息的认证，服务器的资源设置了权限，用户要访问这些资源，就必须要通过身份认证和权限检验，常用的框架有shiro，spring security，还可以结合jwt来实现。

另外，使用jwt token的方式来进行用户的身份认证，后台服务器是不用存储用户的登录信息的，也就没有什么所谓的单点登录的要求了，只需要每个微服务都具有验证jwt token的功能即可