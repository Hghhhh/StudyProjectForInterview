  对于windows来说，进程和线程的概念都是有着明确定义的，进程的概念对应于一个程序的运行实例(instance)，而线程则是程序代码执行的最小单元。CreateThread()用于建立一个新的线程，传递线程函数的入口地址和调用参数给新建的线程，然后新线程就开始执行了。

windows下，一个典型的线程拥有自己的堆栈、寄存器（包括程序计数器PC，用于指向下一条应该执行的指令在内存中的位置），而代码段、数据段、打开文件这些进程级资源是同一进程内多个线程所共享的。因此同一进程的不同线程可以很方便的通过全局变量（数据段）进行通信，大家都可以对数据段进行读写，这很方便，也被在安全性方面诟病，因为它要求程序员时刻意识到这些数据不是线程独立的。

对于linux来说，则没有很明确的进程、线程概念。首先linux只有进程而没有线程，然而它的进程又可以表现得像windows下的线程。linux利用fork()和exec函数族来操作多进程。fork()函数可以在进程执行的任何阶段被调用，一旦调用，当前进程就被分叉成两个进程——父进程和子进程，两者拥有相同的代码段和暂时相同的数据段（虽然暂时相同，但从分叉开的时刻就是逻辑上的两个数据段了，之所以说是逻辑上的，是因为这里是“写时复制”机制，也就是，除非万不得已有一个进程对数据段进行了写操作，否则系统不去复制数据段，这样达到了负担最小），两者的区别在于fork()函数返回值，对于子进程来说返回为0，对于父进程来说返回的是子进程id，因此可以通过if(fork()==0)…else…来让父子进程执行不同的代码段，从而实现“分叉”。

而linux下的进程不能像windows下线程那样方便地通信，因为他们没有共享数据段、地址空间等。它们之间的通信是通过所谓IPC(InterProcess Communication)来进行的。具体有管道（无名管道用于父子进程间通信，命名管道可以用于任意两个进程间的通信）、共享内存（一个进程向系统申请一块可以被共享的内存，其它进程通过标识符取得这块内存，并将其连接到自己的地址空间中，效果上类似于windows下的多线程间的共享数据段），信号量，套接字。  