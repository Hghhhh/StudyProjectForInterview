## -2.操作系统的功能？

操作系统的功能: （1）作业管理　　 （2）文件管理　 （3）存储管理 （4）设备管理 （5）进程管理

##**-1.操作系统的四个基本特性？**

- 并发：允许系统中多个程序并发执行
- 共享：系统中的资源可供并发运行的进程共同使用
- 虚拟：利用某种技术，是得多个用户看上去像是独立占用了一个处理机在运行
- 异步：进程是以不可预知的速度向前推进的。

##**0.进程的特征？**

- 动态性：具有一定的生命周期

- 并发性：多个进程同存于内存，能在一段时间内同时运行

- 独立性：进程是一个独立运行、独立获得资源和独立接受调度的基本单位
- 异步性：进程间是各自独立的，以不可预知的速度向前运行

##**1.进程和程序的区别？进程的特征？**

- 进程是程序的一次执行，进程是活的，是有生命周期的，占有资源的，而程序是一堆代码的集合，是死的，不占有资源。给让程序运行起来并进行资源的分配和调度生成了进程。
- 进程的特征有动态性（即具有一定的生命周期），并发性（多个进程可以在一段时间内同时运行），独立性（每个进程占有独立的资源、能独立运行），异步性（即进程间是各自独立的，以不可预知的速度向前运行）。

##**2.进程的状态？**

创建-》就绪-》执行-》阻塞-》终止

还有挂起：让进程处于静止状态，不参与调度

##**3.进程同步是什么？进程同步有哪些规则？有哪些同步机制？**
进程同步就是让并发进程按一定的时序共享资源，而不产生混乱，从而使程序的执行具有可再现性。

同步机制的规则有：空闲让进，忙则等待，有限等待，让权等待

同步的方法有：

- 硬件同步机制：比如关中断来阻止进程的切换，使用一些原子性的指令来加锁（比如Test-and-Set，Swap）
- 信号量同步机制：为临界资源设置互斥信号量，进程进入临界区之前需要先对信号量进行P操作，出临界区的时候对信号量进行V操作。
- 管程同步机制：利用共享数据结构来代表系统中的共享资源，通过这个共享数据结构来对资源进行操作的一组过程，称为管程，每次只能有一个进程进入管程。这是一种面向对象的思想，把一些操作封装在对象内部，隐藏具体的实现细节。

## 3.2线程同步的方法呢？

- 互斥量(mutex)：互斥量是一种公共资源，在指定时刻，它只能被一个线程占有（也就是所有权特性），而且占有它的线程可以反复申请这个互斥量。只有拥有互斥量的线程才有访问公共资源的权限。因为互斥量只有一个，所以可以保证公共资源不会被多个线程同时访问。（比如Java中的synchronized代码块，需要你提供一个类的对象或Class类作为锁，这个锁就可以理解为互斥量）

- 信号量(semaphore)：每个信号量都是公共资源，其值是一个32位计数。信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由PV操作来改变。
  实现的P，V操作算法描述：
  P操作：while s>0
  s=s-1，
  V操作：s=s+1。
  P表示申请一个资源，如果条件满足（即右可以分配的资源），则把资源分配给提出申请的进程，并且时资源数目s减1。V表示资源使用哪完毕之后，要把占有的资源释放，并且资源数目s加1 。

- 事件（信号 signal）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。（比如Java中的notify（）唤醒wait（）状态的阻塞线程）



##4.**进程通信方式。** 

- 共享内存：在内存中划分一块共享区域，供进程对该区域的读写交换信息。

- 管道：连接一个读进程和一个写进程，进程通过管道输入和读取信息。（单向的）

- 信息队列：一种是利用OS提供的发送原语；另一种是通过共享中间实体进行信息的发送和接收

- 套接字：一种是关联到文件的套接字，同一台机器的环境中，套接字通过对本地特殊文件的读写来传递消息；另一种是网络型套接字，套接字两端绑定接口，建立连接来通信

- 远端过程调用：本地主机调用远程主机的进程，而且看上去就像调用本地进程一样，无需对此进行额外编程。

  ​	

##5.**线程和进程的区别。** 

- 进程是操作系统进行资源分配的基本单位，使用进程来进行任务调度和分派开销较大。线程仅作为CPU任务调度和分派的基本单位，本身不拥有系统资源，开销更小。
- 引入线程的OS比没有引入线程的OS并行性更好
- 同一进程中，线程独立性比不同进程之间的独立性低很多，因为线程共享了进程的内存地址空间和资源。

## 6.**为什么有了进程还要线程呢？**

- 创建进程开销大
- 销毁进程开销大
- 切换进程开销也大，需要不断切换进程的上下文。
- 因而引入线程，线程仅作为独立调度的基本单位，不分配资源，共享线程的上下文，切换的时候开销小。

## **7.线程的实现方式有哪三种？优缺点的是什么？**

- 内核支持线程KST：线程的创建、阻塞、切换都是在内核空间实现的。优点是能够同时调度同一个进程内的多个线程并发执行；线程切换开销小；缺点是：用户对一个线程进行切换时需要从用户态转到内核态才能进行。
- 用户级线程ULT：是在用户空间中实现的，对线程的创建、阻塞、销毁、同步和通信等都不需要内核态的支持。优点是：线程切换不需要进到内核态，与平台无关；缺点是：内核每次分配给进程的CPU只有一个，因此进程中只能有一个在线程执行。
- 组合方式：结合了两者的优点，克服了两者的缺点，主要实现是使用轻型进程LWP来实现的，用户线程连接到LWP上，LWP连接到一个内核线程上，以此来隔开用户线程和内核线程。

##8.什么是内核态，用户态，什么是内核，微内核呢？

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- **用户态** 和 **内核态**

- 内核态：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序
- 用户态：只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取

##9.用户态与内核态的切换？

所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入、发生异常等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.

这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令

这种机制叫**系统调用**, 在CPU中的实现称之为**陷阱指令**(Trap Instruction)

他们的工作流程如下:

1. 用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.
2. 用户态程序执行陷阱指令
3. CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问
4. 这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务
5. 系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果

- 内核：一组程序模块，提供支持进程并发执行的基本功能和操作，运行于内核态，具有直接访问计算机系统硬件设备和所有内存空间的权限。
- 微内核：仅保留内核的基本功能比如和硬件紧密相关的部分、客户服务器之间的通信等，使用客户/服务器模式，微内核作为消息传递机制和提高一些基本功能，其他功能有服务器程序提供。

## 10.作业调度算法有哪些？

- 先来先服务
- 短作业优先
- 优先级调度算法
- 高响应比优先调度算法：优先权=（等待时间+要求服务时间）/服务时间

## 11.进程调度算法有哪些？

- 轮转调度法
- 优先级调度法：动态优先级、静态优先级
- 多队列调度算法；将就绪进程分成多个队列，每个队列使用不同的调度算法



##12.产生死锁的必要条件？

- 互斥条件：资源在一段时间内只能被一个进程占用
- 不剥夺条件：进程已经获得的资源只能由进程自己释放
- 请求和保持条件：进程至少保持了一个资源，同时请求其他资源
- 循环等待条件：多个进程之间的资源循环等待

## 13.处理死锁的方法有哪些？

- 预防死锁：破坏四个必要条件的一个或多个
- 避免死锁：在资源动态分配的过程中，用某种方法避免死锁的发生，比如银行家算法
- 检测死锁：允许死锁的发生，但可以及时的检测出来。
- 解除死锁：检测到死锁时，采取相应的措施来解除，比如回收某个进程的资源

##14.银行家算法是怎么避免死锁的？

每个新进程在进入系统的时候，必须申明在运行过程中，可能需要每种资源类型的最大单元数，其数目不应超过系统所拥有的资源总数。当进程申请一组资源的时候，先判断申请的资源是否小于等于它申明的需求资源，若满足则判断当前可用资源是否足够，足够则分配给它，接下来执行安全性算法判断系统是不是安全的，是则给它，否则恢复。

安全性算法：

（1）设置两个变量，一个是数组Work=Available，一个数组是Finish表示当前进程是否完成。

（2）从进程集合中找到能满足下列条件的进程：

- Finish[i]=false;

- Need[i,j]<=Work[j];

  若找到执行步骤（3），否则执行步骤（4）

（3）当进程pi获得资源后，顺利执行完成，故此时应该释放它的资源：

- Work[j]=Work[j]+Allocation[i,j];
- Finish[i] =true;
- go to step 2;

（4）如果所有进程都是Finsh[i]=true，那么就是安全的，否则不安全。

代码：

```java
class Yinghangjiasuanfa{

	private int[][] allocation;
	private int[][] max;
	private int[] work;
	private int[][] need;
	private boolean[] finish;	
	private int[] available;	
	public Yinghangjiasuanfa(int[][] max,int[] available){
		this.max = max;
		this.available = available;
		for(int i=0;i<max.length;i++){
			for(int j=0;j<available.length;j++){
				if(max[i][j]>available[j])throws RuntimeException("max > available!!!");
			}
		}	
	}	
	
    /**
    申请资源
    **/
	public boolean malloc(int[] apply,int n){
		for(int i=0;i<apply.length;i++){
			if(apply[i]>need[n][i])return false;
			if(apply[i]>available[i])return false;
		}
		for(int i=0;i<apply.length;i++){
			need[n][i]-=apply[i];
			available[i] -= apply[i];
			allocation[n][i]+=apply[i];
		}	
		if(isSecurity())return true;
		else{
			for(int i=0;i<apply.length;i++){
				need[n][i]+=apply[i];
				available[i] += apply[i];
				allocation[n][i]-=apply[i];
			}	
			return false;
		}
	}

    /**
    安全性算法
    **/
	public boolean isSecurity(){
		finish = new boolean[max.length];
		work = Arrays.copyAll(available);
		int i = find();
		while(i!=-1){			
			for(int j=0;j<work.length;j++){
				work[j] = work[j]+allocation[i][j];
			}
			finish[i] = true;
			i = find();
		}
		for(int k=0;k<finish.length;k++){
			if(!finish[k])return false;
		}	
		return true;
	}

    /**
    找一个当前资源可以到分配的序列
    **/
	public int find(){
		for(int i=0;i<max.length;i++){
			boolean flag = true;	
			for(int j=0;j<available.length;j++){
				if(finish[i]==false&&work[j]>=need[i][j]){}
				else flag = false;		
			}
			if(flag){return i;}
		}
		return -1;
	}

}
```

##15.分页和分段存储管理有什么区别？

- 分页：将进程的逻辑地址空间分成若干页，为每页加编号，每页对于一个物理地址块
- 分段：将程序分为若干段，以段为存储单位
- 页是信息的物理单位，页的大小是由系统决定的，固定的，段是信息的逻辑单位，大小有由用户所编写的程序决定，不是固定的

## 16.虚拟存储器的原理是什么？

虚拟存储器不用一次性将作业全部调入内存，而是每次调入需要的部分，调出不需要的部分，让用户感觉到内存容量比实际大很多。

原理是利用程序运行的局限性：空间局限性：程序访问了某个存储单元，附近的存储单元也将被访问；

时间局限性：程序中某条指令被执行，则不久后该指令很可能再次被执行

## 17.请求分页存储管理方式的页面置换算法有哪些？

- 最佳算法：找出不再使用的页面调出，但是一般很难知道那些页面是不再使用的，所以该算法是无法实现的

- 先进先出算法：最先进入内存的页面最先淘汰，缺点是无法保证被淘汰的页面是不经常访问的。

- LRU，最近最久未使用算法，每次淘汰最久未使用的页面

- LFU，最近最少使用算法，每次淘汰最少使用的页面


## 18.什么是抖动？抖动的原因和预防方法?

- 抖动是指刚被换出的页很快就又被访问到，需要将它重新调入，因此需要选择一页调出，调出的页有很快被访问到，因此出现了频繁调入调出的情况。

- 抖动的根本原因是，进程分配到的物理块太少，不能满足进程运行的基本需求，导致频繁的出现缺页。
- 预防方法：
  - 局部置换策略：每个进程只能在自己的内存空间进行置换，不允许从其他进程去获得新的物理块，这样就减少对其他进程的影响
  - 调度程序在调入进程的时候判断是否有足够的内存空间可以调入进程所需的工作集，如果内存不足就先不调入
  - 让缺页之间的平均时间L尽量等于平均缺页服务时间S，这样能提供磁盘和处理的利用率
  - 多道程序数偏高时，需要减少多道程序数，基于某种原则暂停当前某些活动进程，让出内存空间。

## 19.磁盘存储器：磁盘访问时间是有什么决定的？

- 寻道时间：把磁头移动到指定磁道上的时间
- 旋转延迟时间：将指定扇区旋转到磁头所需的时间
- 读写时间：读写磁盘数据的时间

## 20.磁盘调度算法有哪些？

- 先来先服务（FCFS）：那个程序先发起IO请求就先去处理，这样比较公平，但寻道时间长
- 最短寻道时间优先（SSTF）：选择离当前磁头最近的磁道移动，但是不能保证平均寻道时间最短，而且可能会使距离磁头较远的IO请求一直不能得到满足（饥饿现象）
- 扫描算法（SCAN，电梯调度算法）：磁头先自里向外移动直到无更外的磁道需要访问，才将磁头换为自外向里移动
- 循环扫描算法（CSAN）：和电梯调度算法相似，不过每次移动到最外的时候，磁头回到最里的待访问磁道。这样的好处让请求访问里面磁道的请求不会等待太久。

##21.什么是缓冲区溢出？有什么危害？其原因是什么？
缓冲区为暂时置放输出或输入资料的内存。

**缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上**。

缓冲区溢出是一种非常普遍、非常危险的漏洞，在很多软件与操作系统都存在这种问题。

举个例子帮助理解其本质，好比你往一个100ml容量的烧杯里倒200ml浓硫酸，实际情况下你肯定不会这么做，但是溢出的问题就在于有人想这么做了，而且这个倒的行为没有被提前检查并阻止。于是100ml的浓硫酸溢出烧杯，并且流到烧杯外的周围区域，造成破坏。而哪怕你倒的不是浓硫酸（非恶意程序），只是普通的水，由于水的溢出，也会对周围的环境造成意料外的冲刷（对临近数据的覆盖）。

计算机中，缓冲区溢出会造成的危害主要有以下两点：

- **程序崩溃，导致拒绝服务**
- **跳转并且执行一段恶意代码**

**造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。**

如果你想深入了解缓冲区溢出，推荐阅读：[缓冲区溢出攻击](http://www.cnblogs.com/fanzhidongyzby/archive/2013/08/10/3250405.html)

##22.请阐述动态链接库与静态链接库的区别？
解答：静态链接库是.lib格式的文件，一般在工程的设置界面加入工程中，**程序编译时会把lib文件的代码加入你的程序中因此会增加代码大小**，你的程序一运行lib代码强制被装入你程序的运行空间，不能手动移除lib代码。

**动态链接库是程序运行时动态装入内存的模块，格式*.dll，在程序运行时可以随意加载和移除，节省内存空间。**

在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个lib文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内存，这样可以节省内存空间。



## 补充：

### 1.1 同步与异步



#### 同步与异步的理解

同步与异步的重点在消息通知的方式上，也就是调用结果通知的方式。 
`同步`: 当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行。 
`异步`：当一个异步调用发出去后，调用者不能立即得到调用结果的返回。 
异步调用，要想获得结果，一般有两种方式：

> 1. 主动轮询异步调用的结果;
> 2. 被调用方通过callback来通知调用方调用结果。



#### 生活中的例子

`同步买奶茶`：小明点单交钱，然后等着拿奶茶；异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。

`异步买奶茶`: 小明要想知道奶茶是否做好了，有两种方式：

> 1. 小明主动去问店员，一会就去问一下：“奶茶做好了吗？”...直到奶茶做好。这叫轮训。
> 2. 等奶茶做好了，店员喊一声：“小明，奶茶好了！”，然后小明去取奶茶。这叫回调。



### 1.2 阻塞与非阻塞



#### 阻塞与非阻塞的理解

阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在等待消息的时候，当前进/线程是挂起状态，还是非挂起状态。

`阻塞调用`在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.

`非阻塞`调用在发出去后，不会阻塞当前进/线程，而会立即返回。



#### 生活中的例子

`阻塞买奶茶`：小明点单交钱，干等着拿奶茶，什么事都不做； 
`非阻塞买奶茶`：小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈。



### 1.3 总结

通过上面的分析，我们可以得知：

> 1. 同步与异步，重点在于消息通知的方式;
> 2. 阻塞与非阻塞，重点在于等消息时候的行为。

所以，就有了下面4种组合方式：

> 1. 同步阻塞：小明在柜台干等着拿奶茶；
> 2. 同步非阻塞：小明在柜台边刷微博边等着拿奶茶；
> 3. 异步阻塞：小明拿着小票啥都不干，一直等着店员通知他拿奶茶；
> 4. 异步非阻塞：小明拿着小票，刷着微博，等着店员通知他拿奶茶。



###1.4 I/O多路复用

I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流. 发明它的原因，是尽量多的提高服务器的吞吐能力。

参考：[异步、同步、阻塞、非阻塞、IO多路复用](https://www.zybuluo.com/phper/note/595507)