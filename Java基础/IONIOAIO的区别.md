BIO:同步阻塞，那java的Socket来说，每次发起一次连接都需要创建一个线程去读取数据，等待接收数据的期间线程阻塞着。

NIO：同步非阻塞，NIO提供了一个Selector多路复用器，我们只需要把Channel注册到这个多路复用器中，并声明自己感兴趣的事件即可，这个Selector会帮我们监控有无事件的发送，然后通知Channel去处理。这样就不用给每个连接都创建一个线程，减少了线程上下文切换的开销。



AIO：异步非阻塞，AIO是客户端的I/O请求都交由OS先完成了，再通知服务器应用去启动线程进行处理。



BIO、NIO、AIO适用场景分析:

- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
- NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
- AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。



Reactor和Proactor对比

Reactor：

1.启动应用，将关注的事件注册到Reactor中

2.调用Reactor，进入无限事件循环，等待注册事件的到来

3.注册事件到来，select返回，之前将事件分发给注册的回调函数处理



Proactor:
1.调用操作系统的异步处理接口，之后应用程序和操作系统就可以独立运行；

2.操作系统完成IO操作之后，将结果放入完成事件队列

3.主动器从事件队列中取出结果，分发到完成事件的回调函数中去。

