# 面向对象和面向过程的优缺点

面向过程是以事件为中心，按照我们编写的代码是根据完成一个步骤的过程来进行。

面向对象以对象为中心，我们把要完成的功能封装成一个一个的对象，调用对象的方法或属性来完成功能。



##面向对象相比面向过程的好处：

**封装**：我们可以根据不同功能和操作的数据来封装成不同对象，由对象实现具体的操作，我们只需要调用对象的方法即可，代码简洁、而且方便测试。

可能你会说面向过程也可以分离出一个一个的函数出来啊，也可以分成各个模块来调用啊，为什么要用面向对象？

接下来看下面的特性：

**继承**：假如有同一类操作，然后这些操作都有一部分共同的操作，通过面向对象，我们可以让子类对象继承父类对象，父类对象同实现了这部分操作，所有子类对象都可以很容易复用这些代码，不用自己实现一遍。

那你可能有会说，面向过程也可以分离出公共的函数来调用吧，为什么要面向对象？

好，接下来看下面向对象的这个特性：

**多态**：其实前面的继承不单单是复用了父类的代码，还表示所有继承了父类的子类都是同一类对象。

假如我们有这么一个操作，要判断传进来的动物类型，然后执行这个动物的eat操作，面向过程是怎么做的呢？

```c
void dogEat(){
    ...
}
void catEat(){
    ...
}
void humanEat(){
    ...
}
void eat(String s){
    if(s=="dog")dogEat();
    if(s=="cat")catEat();
    if(s=="human")humamEat();
}
```

面向过程是上面这么做的，也就是在编译期就一定会确定调用了哪个函数，而且要写一大堆判断代码，假如又加进来了几种动物，又得修改这份代码，耦合度很高。

而面向过程是这么做的：

```java
class Animal {
    void eat(){
        
    }
}
class Dog extends Ainmal{ 
	 void eat(){
     	...   
    }
}

class Cat extends Ainmal{ 
	 void eat(){
     	...   
    }
}

class Human extends Ainmal{ 
	 void eat(){
     	...   
    }
}

void eat(Animal a){
    a.eat();
}
```

通过多态，我们只需要声明我需要某一类对象的父类，然后传进来一个具体子类，在运行的时候我们调用的是子类的方法。而且不管后面有加多了多少个子类，都不用改我写好的代码，耦合度大大降低，而且代码易维护。



这下没话说了吧，哈哈



##那么面向对象有什么缺点嘛？

面向过程的性能比面向对象高,因为类调用时需要实例化,开销比较大,比较消耗资源，所以单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。



##总结：

面向对象：代码易复用、易测试、易扩展、耦合度低、易维护。但性能没面向过程高，因为有对象的实例化，开销较大。



面向过程：没有面向对象的易复用、易测试、易扩展、耦合度低、易维护。但性能高。

