---
title: 早期（编译期）优化
date: 2018-09-04 19:57:22
tags: JVM
---



*整理自《深入理解Java虚拟机第二版》*

#一、概述

JVM的编译器可以分为三个编译器：  

- 前端编译器：把*.java转变为*.class的过程。如Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。 

- JIT编译器（即时编译器）：把字节码转变为机器码的过程，如HotSpot VM的C1、C2编译器。
- AOT编译器：静态提前编译器，直接将*.java文件编译本地机器代码的过程。

Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在优化过程对于程序编码来说关系更加密切。

<!--more-->

#二、Javac编译器

从Sun Javac的代码来看，编译过程大致可以分为3个过程，分别是：

- 解析与填充符号表过程
- 插入式注解处理器的注解处理过程
- 分析与字节码生成过程

这3个步骤之间的关系与交互顺序如下：
![Javac的编译过程](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/javac%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.JPG)

## 2.1解析与填充符号表

### 2.1.1词法、语法分析

​	词法分析是将源码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。

​	语法分析是根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方法，语法数的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等。经过这个阶段后编译器就基本不会对源码文件进行操作了，后续的操作都建立在抽象语法树之上了。

### 2.1.2填充符号表

​	符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析阶段中，符号表所登记的内容将进行语义检查和产生中间代码；在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

## 2.2注解处理器

 	在JDK1.6中实现了JSR-269规范提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插人式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是上图中的回环过程。

## 2.3语义分析与字节码生成

​	语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

### 2.3.1标注检查

​	标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否匹配等。在标注检查中，有一个重要的动作：**常量折叠**。

​	如果我们在代码中写了如下定义：`int a = 1+2;`那么在语法树上仍然能看到字面量“1”，“2”以及操作符“+”，但是在经过常量折叠后，它们将会被折叠为字面量“3”，这个插入式表达式的值已经在语法树上标注出来了。由于在编译期进行了常量折叠，所以在代码里面定义“a=1+2“比起直接定义”a=3“，并不会增加程序运行期间的CPU指令运算量。

### 2.3.2数据及控制流分析

​	数据及控制流分析是对程序上下文逻辑更近一步的验证，它可以检查出诸如程序局部变量在使用前是否赋值、方法的每条路径是否有返回值、是否所以的受查异常都被正确处理等问题。

​	值得注意的是虽然这里的数据及控制流分析与类加载时的数据及控制流分析的目的基本一致，但校验范围是有所区别，一些校验项只有在编译期或运行期才能进行。例如局部变量在Class文件的常量池中没有符号引用，自然就没有访问标志的信息，所以在Class文件中不可能知道一个局部变量的访问标志。因此，如果将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅在编译期间保障。

### 2.3.3解语法糖

​	语法糖（Syntactic Sugar）指在计算机语言中添加某种方便使用的对语言功能没有影响的语法。Java中最常用的语法糖主要是泛型、变长参数、自动装箱/拆箱等。虚拟机运行时不支持这些语法，所以它们在编译阶段还原回简单的基础语法，这个过程称为解语法糖。

### 2.3.4字节码生成

​	字节码生成时javac编译过程的最后一个阶段，不仅仅是把前面各个阶段所生成的信息转化为字节码写到磁盘，编译器还进行了少量代码的添加和转换工作。

​	例如实例构造器`<init>`方法和类构造器`<clinit>`方法就是这个阶段添加到语法树中的。（注意，这里的实例构造器并不是指默认的构造函数，这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把语句块、变量初始化、调用父类的实例构造器等操作收敛到`<init>`、`<clinit>`方法中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行）

​	除了生成构造器外，还有其他的一些代码替换工作，如把字符串的加操作替换为StringBuffer或StringBuilder的append操作等。