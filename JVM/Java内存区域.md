---
title: Java内存区域
date: 2018-08-27 17:28:33
tags: JVM
---

*整理自《深入理解Java虚拟机--JVM高级特性与最佳实践第二版》*

> Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。

Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁：

![img](https://images2015.cnblogs.com/blog/874710/201612/874710-20161206164443851-339965653.png)

<!--more-->



#1.程序计数器

​	程序计数器是一块较小的内存空间，**它可以看作是当前线程所执行的字节码的行号指示器**。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

#2.Java虚拟机栈

​	与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期也线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出入口等信息。**每一个方法从调用直到执行完成的过程，就对于着一个栈帧在虚拟机栈中的入栈出栈的过程。**

​	Java虚拟机栈可能发生如下异常情况：

- 如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一一个StackOverflowError异常。

- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。

##2.1栈帧

​	栈帧的存储空间由创建它的线程分配在Java虚拟机栈中，每个栈帧中都有自己的局部变量表、操作数栈和指向当前方法所属类的运行时常量池的引用。栈帧中还允许携带与Java虚拟机实现相关的一些附加信息，例如，对程序调试提供支持的信息。

​	在某条线程执行过程中的某个时间点上，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧称为当前栈帧，这个栈帧对应的方法称为当前方法，定义这个方法的类称作当前类。对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的局部变量表和操作数栈所进行的操作。

![栈帧](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%A0%88%E5%B8%A7.JPG)

###2.1.1局部变量表

​	每个栈帧内部都包含一组称为局部变量表的变量列表。栈帧中局部变量表的长度由编译期决定，并且存储于类或接口的二进制表示之中，即通过方法的code属性保存及提供给栈帧使用。

​	局部变量表的容量以Slot为最小单位，一个Slot可以保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress的数据。两个Slot可以保存一个类型为long或double的数据。

​	局部变量使用索引来进行定位访问。首个局部变量的索引值为0。局部变量的索引值是个整数，它大于等于0，且小于局部变量表的长度。

###2.1.2操作数栈

​	每个栈帧内部都包含一个称为操作数栈的后进先出（Last-In-First-Out，LIFO)栈。栈帧中操作数栈的最大深度由编译期决定，并且通过方法的code属性保存及提供给栈帧使用。

​	在任意时刻，操作数栈都会有一个确定的栈深度，一个long或者double类型的数据 会占用两个单位的栈深度，其他数据类型则会占用一个单位的栈深度。

###2.1.3动态连接

​	每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。在class文件里面，一个方法若要调用其他方法，或者访问成员变量，则需要通过符号引用来表示，动态链接的作用就是将这些以符号引用所表示的方法转换为对实际方法的直接引用。类加载的过程中将要解析尚未被解析的符号引用，并且将对变量的访问转化为变量在程序运行时，位于存储结构中的正确偏移量。

#3.本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务·在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它·甚至有的虚拟机（譬如SunHotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一·与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

#4.Java堆

​	对于大多数应用来说，Java堆(JavaHeap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配的。

​	存储在JVM中的Java对象可以被划分为两类：一类是生命周期较短的瞬时对象，这类对象“朝生夕死”；而另一类对象的生命周期却非常长。因此对这些不同的生命周期的java对象，应该采取不同的垃圾收集策略，分代收集由此诞生。所以Java堆还可细分为新生代(YoungGen)和老年代(OldGen)，其中的新生代又可以划分为Eden空间、From Survivor空间和To Survivor空间：(Eden：survivor默认是8：1)

![java堆](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/java%E5%A0%86.jpg)

#5.方法区

​	方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

##5.1运行时常量池

运行时常量池属于方法区中的一部分，一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表，那么**运行时常量池就是字节码文件中常量池表的运行时表示形式**。运行时常量池中包含多种不同的常量，比如编译期就已经明确的数值字面量到运行期解析后才能够获得的方法或者字段引用。运行时常量池类似于传统编程语言中的符号表，但是它所包含的数据却比符号表要更加丰富一些。 

