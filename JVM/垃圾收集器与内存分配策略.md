---
title: JVM的垃圾收集
date: 2018-08-27 17:29:25
tags: JVM
---

*整理自《深入理解Java虚拟机--JVM高级特性与最佳实践第二版》*	

​	Java内存运行时区域中的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈帧分配多少内存基本是在类结构确定下来就已知的。因此在这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要考虑过多内存回收的问题，因为方法结束或线程结束，内存自然就跟着回收了。而Java堆和方法区则不同，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。



# 一、对象已死吗？

​	在堆里面存放着Java世界中几乎所有的对象实例，垃圾回收前，第一件事情就是确认哪些对象“活着”，哪些对象已“死去”。

<!--more-->



##1.引用计数法

​	所谓引用计数法是这样的：**给每个对象添加一个引用计数器，每当有一个地方引用它是，计数器就加1；引用失效时，计数器就减1；当计数器为0是，该对象失效。**

​	但是，主流的Java虚拟机并不是使用引用计数法进行内存管理的，其中主要的原因是它很难解决对象之间相互循环引用的问题。

​	如下图Java堆中的这块区域对象实例之间存在相互引用，导致这四个对象的程序计数器的值都不为0，而虚拟机栈中已经不存在这四个对象的引用，但是这四个对象所占的内存仍得不到清理。

![引用计数法](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.jpg)

## 2.可达性分析算法

​	这个算法的基本思想就是**通过一系列的称为“GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Root没有任何引用链相连时，则证明此对象是不可用的。**

​	如下图对象D、E、F虽然互相关联，但是它们到GC Roots是不可达的，所以它们将会被判定为可回收对象。

![可达性分析算法](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg)

​	在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即Native方法）引用的对象。

## 3.再谈引用

​	堆中一个对象实例如果只有被引用和不被引用两种状态，不被引用时就被清理掉，那么对于描述一些”食之无味，弃之可惜“的对象就显得无能为力。

​	JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种：

- 强引用就是指在程序代码之中普遍存在的，类似“Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。
- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。

## 4.回收方法区

​	方法区的垃圾收集效率远低于Java堆。方法区的垃圾收集主要回收两部分的内容：废弃常量和无用的类。回收废弃常量和回收Java堆中的对象非常类似，如果当前系统中没有使用到该常量，在必要的时刻，该常量就会被系统清理掉。

​	判断一个常量是否”废弃“比较简单，那么如何判断一个类是否是”无用的类“呢：

- 该类所有实例都已经被回收，也就是Java堆中不再有该类的任何实例。
- 加载该类的ClassLoader已经被回收了。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​      值得注意的是，在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁定义ClassLoader的场景都需要虚拟机具备类卸载的功能，保证方法区不会溢出。

# 二、垃圾收集算法

## 1.标记-清除算法

​	它是最基础的收集算法，因为后续的收集算法都是基于这种思路对其不足进行改进得到的。算法分为”标记“和”清除“两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所以被标记的对象。它的不足主要有两个：一是效率问题，标记和清除两个过程效率都不高；二是空间问题，标记清除后产生大量不连续内存碎片，内存碎片过多时，假如需要发配较大的对象时，无法找到足够的连续内存就不得不提前触发一次垃圾收集动作。标记-清除算法执行过程如下：

![标记-清除算法](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%8D%95%E8%8E%B7.JPG)

## 2.复制算法

​	复制算法解决了内存碎片化的问题，它将可用内存划分为大小相等的两块，每次只使用其中一块，当这块内存用完了，就将还存活的对象复制到另一块内存上，然后把使用过的这块内存一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片化等复杂情况。但是这样每次只用了一半的内存区域，造成很大的浪费。

![复制算法](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E5%A4%8D%E5%88%B6.JPG)

现在的商业虚拟机都是采用这种收集算法来回收新生代，新生代中的对象98%都是”朝生夕死“的，所以并不需要1:1的比例来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间，HotSpot虚拟机默认的Eden和Survivor的比例是8：1，也就是新生代代可用内存空间为整个新生代容量的90%，只有10%的内存会被浪费。那么，如果回收的时候存活的对象所占内存大于10%怎么办？当Survivor空间不够用时，需要依赖老年代进行分配担保。如果Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

## 3.标记-整理算法

​	复制收集算法在对象存活率高的老年代中显然不适用，为此，有人根据老年代的特点，提出了”标记-整理算法“：标记过程和”标记-清除算法“一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。”标记-整理“算法的示意图如下：

![标记整理算法](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.JPG)

## 4.分代收集算法

​	这种算法根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以各个年代的特点采取最适当的收集算法。比如新生代的对象”朝夕生死“那就使用复制算法，老年代中对象存活率高而且没有额外的空间对它进行分配担保，就必须使用”标记-清理“或”标记-整理“算法。

# 三、内存分配与回收策略

## 1.对象优先在Eden分配

​	在大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。

## 2.大对象直接进入老年代

​	所谓的大对象是指需要大量连续内存空间的Java对象。

## 3.长期存活的对象将进入老年代

​	虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过一个MinorGC后仍然存活且能被Survivor容纳的话，将被移动到Survivor空间中，年龄加1，当年龄到达晋升老年代的年龄阈值（默认15岁），就会被放到老年代。

## 4.动态对象年龄判定

​	为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenunngThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenurmgThreshold中要求的年龄。

## 5.空间分配担保

​	在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，S那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

​	这里的冒险是指老年代的剩余连续空间不足以容纳Survivor送过来的对象，可能会出现HandlePromotionFailure即担保失败，那就只好在失败后重新发起一个Full GC。虽然担保失败是绕的圈子是最大的，但大部分情况下还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。