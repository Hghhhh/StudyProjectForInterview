##常用的垃圾收集器有哪些？哪些是新生代的？哪些是老年代的？

### Serial收集器

新生代收集器

是一个单线程的收集器，使用复制算法进行垃圾收集时候，必须停止其他所有的工作线程。

优点：简单高效

缺点：“stop-the-world”会给用户带来不良体验

适用场景：适用于垃圾收集停顿时间小的运行在Client模式下的虚拟机



###ParNew收集器

新生代收集器

Serial的多线程版本，一样是“stop-the-world”，复制算法

优点：多CPU环境下相比Serial可以有效地利用CPU资源

缺点：同Serival

适用场景：多CPU环境，（默认开启的收集线程数和CPU数相同，可以使用-XX:ParallelGCThreads来限制收集的线程数），和CMS收集器配合工作的情况下。（因为用CMS作为老年代收集器的时候，新生代收集器只能使用Serial或ParNew）



### Parallel Scavenge收集器

新生代收集器

和ParNew一样是并行的多线程收集器，但它的关注点在吞吐量，（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）），高吞吐量可以保证高效率的利用CPU时间。它提供了两个精确的参数来控制吞吐量：

`-XX：MaxGCPauseMillis`(控制最大停顿时间)，`-XX:GCTimeRatio`(控制垃圾收集时间占总时间的比值)

另外它还提供了自适应调节策略，可以根据系统运行情况动态调节最合适的停顿时间或最大的吞吐量，可以通过参数`-XX:UseAdaptiveSizePolicy`开启

优点：专注吞吐量，保证高效率的利用CPU

缺点：未知

适用场景：如果对于收集器的运作不太了解，手工优化存在困难，可以考虑使用Parallel Scavenge的自适应调节策略



###Serial Old收集器

老年代收集器

Serival的老年代版本，同样是一个单线程收集器，使用标记-整理算法

适用场景: 

- 与Parallel Scavenge配合使用
- 作为CMS收集器发生Concurrent Mode Failure时的后配预案



###Parallel Old收集器

老年代收集器

Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法

适用场景：在吞吐量和CPU资源敏感的场合，使用Parallel Scavenge和Parallerl Old收集器



###CMS收集器

老年代收集器

它是一种以获得最短回收停顿时间为目标的收集器，使用标记-清除算法

整个回收过程分为：

- 初始标记：标记GCRoot能直接到达的关联对象，这时候需要停止其他用户线程，但这个时间很短
- 并发标记：进程GCRoot Tracing的过程，是和用户线程并发执行的
- 重新标记：通知用户线程，修正并发标记期间用户程序继续运行而导致的标记变动
- 并发清除：进行垃圾回收，是和用户线程一起并发执行的

由于整个过程中最占时间的并发清除是和用户线程一起工作的，所以可以将CMS的回收过程看做是用户线程并发执行的



优点：真正意义上的垃圾线程和用户线程并发执行，系统停顿时间短

缺点：

- CMS对CPU资源非常敏感，因为占用了一部分线程而导致应用程序变慢，启动的默认垃圾回收线程数是（CPU数量+3）/4，在CPU数少的情况下，CPU分到用户线程的就会资源就会少很多，导致用户程序速度大幅下降
- CMS收集器无法处理浮动垃圾：浮动垃圾就是并发清除的时候系统生成的垃圾，只能留到下次清除；而且由于需要预留一部分空间给并发收集时使用，所以不能等到老年代满了再回收垃圾，如果预留的空间不够就会发生“Concurrent Mode Failure”失败，改用Serial Old收集器来重新收集，导致停顿时间更长。可以通过`-XX:CMSInitiatingOccupancyFraction`的值来设置触发垃圾收集的百分比。
- CMS基于标记-清除算法，可能会产生大量的内存碎片，导致Full GC不得不提前触发。CMS提供了`-XX:UseCMSCompactAtFullCollection`参数来要求进行Full GC之前必须进行一次内存整理，`-XX:CMSFullGCsBeforeCompaction`来设置执行多少次不内存整理的Full GC之后要进行一次内存整理的Full GC	

适用场景：B/S模式下的服务器端，要求响应速度快，停顿时间短，以给用户带来比较好的体验



### G1收集器

使用分代收集算法，所以它是一个新生代老年代都可以使用的收集器

它将Java堆划分成一个个大小相等的Region，G1跟踪各个Region的回收的价值，在后台维护一个优先列表，优先回收价值最大的Region。为了避免全堆扫描，G1在每个Region中维护了一个对应的Remembered Set，当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set，即可保证不对全堆进行扫描也不会有遗漏。

优点：

- 并发与并行：重复利用多CPU、多核环境的优势，来缩短停顿时间。
- 分代收集：不需要其他收集器配合
- 空间整合：相比CMS的标记-清除，它整体上使用标记-整理算法，两个Region之间使用复制算法。意味着不会产生内存碎片
- 可预测的停顿：可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

简单来说，如果你的应用追求低停顿，那使用G1是不错的选择，如果追求吞吐量，那使用G1并不会为你带来什么好处



##垃圾收集器的参数有哪些？

![](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0.jpg)

![](https://3116004636-1256103796.cos.ap-guangzhou.myqcloud.com/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B02.jpg)



参考：《深入了解Java虚拟机第二版》-周志明